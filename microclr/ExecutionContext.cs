using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using static microclr.MicroClrStack;

namespace microclr
{
	struct ExecutionContext
	{
		MethodInfo method;
		byte[] il;
		int ip;

		MicroClrStack Stack;

		public ExecutionContext(MethodInfo method, MicroClrStack stack)
		{
			this.method = method;
			Stack = stack;

			il = method.GetMethodBody().GetILAsByteArray();
			ip = 0;
		}

		public object Execute()
		{
			Span<Variable> locals = stackalloc Variable[method.GetMethodBody().LocalVariables.Count];

			while (true)
			{
				OpCodeValues opcode = ReadOpCode();

				// This page describes the behaviour of all the instructions.
				// https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes?view=netcore-3.1

				switch (opcode)
				{
					// Do nothing
					case OpCodeValues.Nop:
						break;

					// TODO Ldarg

					#region Store a value to a local variable
					case OpCodeValues.Stloc:
						locals[ReadUShort()] = Stack.Pop();
						break;
					case OpCodeValues.Stloc_S:
						locals[il[ip++]] = Stack.Pop();
						break;
					case OpCodeValues.Stloc_0:
						locals[0] = Stack.Pop();
						break;
					case OpCodeValues.Stloc_1:
						locals[1] = Stack.Pop();
						break;
					case OpCodeValues.Stloc_2:
						locals[2] = Stack.Pop();
						break;
					case OpCodeValues.Stloc_3:
						locals[3] = Stack.Pop();
						break;
					#endregion

					#region Push a local to the stack
					case OpCodeValues.Ldloc:
						Stack.Push(locals[ReadUShort()]);
						break;
					case OpCodeValues.Ldloc_S:
						Stack.Push(locals[il[ip++]]);
						break;
					case OpCodeValues.Ldloc_0:
						Stack.Push(locals[0]);
						break;
					case OpCodeValues.Ldloc_1:
						Stack.Push(locals[1]);
						break;
					case OpCodeValues.Ldloc_2:
						Stack.Push(locals[2]);
						break;
					case OpCodeValues.Ldloc_3:
						Stack.Push(locals[3]);
						break;
					#endregion

					#region Push literal to the stack
					case OpCodeValues.Ldnull:
						Stack.PushULong(0);
						break;
					case OpCodeValues.Ldc_I4:
						Stack.PushInt(ReadInt());
						break;
					case OpCodeValues.Ldc_I4_S:
						Stack.PushInt((sbyte)il[ip++]);
						break;
					case OpCodeValues.Ldc_I4_0:
						Stack.PushInt(0);
						break;
					case OpCodeValues.Ldc_I4_1:
						Stack.PushInt(1);
						break;
					case OpCodeValues.Ldc_I4_2:
						Stack.PushInt(2);
						break;
					case OpCodeValues.Ldc_I4_3:
						Stack.PushInt(3);
						break;
					case OpCodeValues.Ldc_I4_4:
						Stack.PushInt(4);
						break;
					case OpCodeValues.Ldc_I4_5:
						Stack.PushInt(5);
						break;
					case OpCodeValues.Ldc_I4_6:
						Stack.PushInt(6);
						break;
					case OpCodeValues.Ldc_I4_7:
						Stack.PushInt(7);
						break;
					case OpCodeValues.Ldc_I4_8:
						Stack.PushInt(8);
						break;
					case OpCodeValues.Ldc_I4_M1:
						Stack.PushInt(-1);
						break;
					case OpCodeValues.Ldc_I8:
						Stack.PushLong(ReadLong());
						break;
					case OpCodeValues.Ldc_R4:
						Stack.PushFloat(ReadFloat());
						break;
					case OpCodeValues.Ldc_R8:
						Stack.PushDouble(ReadDouble());
						break;
					#endregion

					#region Branch
					case OpCodeValues.Br:
						ip += ReadInt() + 4;
						break;
					case OpCodeValues.Br_S:
						ip += (sbyte)il[ip] + 1;
						break;
					#endregion

					#region Operators
					case OpCodeValues.Add:
						if (Stack.Peek().Type == VariableType.Float)
						{
							// For correctness I should check if both arguments are float,
							// however that will make it slower and the check isn't really
							// needed because the code being run is generated by the C#
							// compiler, so it is safe to assume the IL is valid.
							Stack.PushFloat(Stack.PopFloat() + Stack.PopFloat());
							break;
						}
						else if (Stack.Peek().Type == VariableType.Double)
						{
							Stack.PushDouble(Stack.PopDouble() + Stack.PopDouble());
							break;
						}
						Stack.PushLong(Stack.PopLong() + Stack.PopLong());
						break;
					case OpCodeValues.Sub:
						if (Stack.Peek().Type == VariableType.Float)
						{
							Stack.PushFloat(-Stack.PopFloat() + Stack.PopFloat());
							break;
						}
						else if (Stack.Peek().Type == VariableType.Double)
						{
							Stack.PushDouble(-Stack.PopDouble() + Stack.PopDouble());
							break;
						}
						Stack.PushLong(-Stack.PopLong() + Stack.PopLong());
						break;
					case OpCodeValues.Mul:
						if (Stack.Peek().Type == VariableType.Float)
						{
							Stack.PushFloat(Stack.PopFloat() * Stack.PopFloat());
							break;
						}
						else if (Stack.Peek().Type == VariableType.Double)
						{
							Stack.PushDouble(Stack.PopDouble() * Stack.PopDouble());
							break;
						}
						Stack.PushLong(Stack.PopLong() * Stack.PopLong());
						break;
					case OpCodeValues.Div:
						if (Stack.Peek().Type == VariableType.Float)
						{
							var divisorf = Stack.PopFloat();
							var dividendf = Stack.PopFloat();
							Stack.PushFloat(dividendf / divisorf);
							break;
						}
						else if (Stack.Peek().Type == VariableType.Double)
						{
							var divisord = Stack.PopDouble();
							var dividendd = Stack.PopDouble();
							Stack.PushDouble(dividendd / divisord);
							break;
						}
						var divisor = Stack.PopLong();
						var dividend = Stack.PopLong();
						Stack.PushLong(dividend / divisor);
						break;
					case OpCodeValues.Neg:
						if (Stack.Peek().Type == VariableType.Float)
						{
							Stack.PushFloat(-Stack.PopFloat());
							break;
						}
						else if (Stack.Peek().Type == VariableType.Double)
						{
							Stack.PushDouble(-Stack.PopDouble());
							break;
						}
						Stack.PushLong(-Stack.PopLong());
						break;
					#endregion

					#region Return
					case OpCodeValues.Ret:
						// I feel like there may be a better way to do this than
						// switching on the return type and boxing the return value
						var retType = method.ReturnType;
						if (retType == typeof(void))
						{
							return null;
						}
						else
						{
							var ret = Stack.Pop();
							if (retType == typeof(sbyte))
							{
								return (sbyte)ret.Value;
							}
							else if (retType == typeof(byte))
							{
								return (byte)ret.Value;
							}
							else if (retType == typeof(short))
							{
								return (short)ret.Value;
							}
							else if (retType == typeof(ushort))
							{
								return (ushort)ret.Value;
							}
							else if (retType == typeof(int))
							{
								return (int)ret.Value;
							}
							else if (retType == typeof(uint))
							{
								return (uint)ret.Value;
							}
							else if (retType == typeof(long))
							{
								return (long)ret.Value;
							}
							else if (retType == typeof(ulong))
							{
								return ret.Value;
							}
							else if (retType == typeof(float))
							{
								return BitConverter.Int32BitsToSingle((int)ret.Value);
							}
							else if (retType == typeof(double))
							{
								return BitConverter.Int64BitsToDouble((long)ret.Value);
							}
							else if (retType == typeof(bool))
							{
								return ret.Value != 0;
							}
							else
							{
								throw new NotImplementedException();
							}
						}
					//var ret = Stack.Pop();
					//switch (ret.Type)
					//{
					//	case VariableType.Int:
					//		return (long)ret.Value;
					//	case VariableType.UInt:
					//		return ret.Value;
					//	case VariableType.Float:
					//		return BitConverter.Int32BitsToSingle((int)ret.Value);
					//	case VariableType.Double:
					//		return BitConverter.Int64BitsToDouble((long)ret.Value);
					//	default:
					//		throw new NotImplementedException();
					//}
					#endregion

					default:
						throw new UnsupportedInstructionException(opcode);
				}
			}
		}

		public T Execute<T>() where T : unmanaged
		{
			return (T)Execute();
			//Execute();
			//var ret = Stack.PopULong();
			//return MemoryMarshal.Cast<ulong, T>(MemoryMarshal.CreateSpan(ref ret, 1))[0];
		}

		internal string Disassemble()
		{
			// TODO This is wrong and should be fixed

			StringBuilder sb = new StringBuilder();

			while (ip != il.Length)
			{
				var op = ReadOpCode();
				sb.AppendLine(op.ToString());
			}

			return sb.ToString();
		}

		private OpCodeValues ReadOpCode()
		{
			OpCodeValues opcode = (OpCodeValues)il[ip++];
			if (opcode > OpCodeValues.Prefix7)
			{
				opcode = (OpCodeValues)(il[ip++] | ((ushort)opcode << 8));
			}

			return opcode;
		}

		private ushort ReadUShort()
		{
			ushort i = BitConverter.ToUInt16(il, ip);
			ip += sizeof(ushort);
			return i;
		}

		private int ReadInt()
		{
			int i = BitConverter.ToInt32(il, ip);
			ip += sizeof(int);
			return i;
		}

		private long ReadLong()
		{
			long i = BitConverter.ToInt64(il, ip);
			ip += sizeof(long);
			return i;
		}

		private float ReadFloat()
		{
			float f = BitConverter.ToSingle(il, ip);
			ip += sizeof(float);
			return f;
		}

		private double ReadDouble()
		{
			double d = BitConverter.ToDouble(il, ip);
			ip += sizeof(double);
			return d;
		}
	}
}
